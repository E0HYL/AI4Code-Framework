#!/usr/bin/env python
# -*- encoding: utf-8 -*-
'''
@File    :   mamadroid.py
@Time    :   2021/10/02 18:42:45
@Author  :   Yiling He
@Version :   1.0
@Contact :   heyilinge0@gmail.com
@License :   (C)Copyright 2021
@Desc    :   MamaDroid (https://arxiv.org/pdf/1612.04433.pdf) also provides “family mode” where calls to APIs are abstracted to calls to families, but its authors prove that “package mode” is much better, so in this paper we only consider MamaDroid in package mode, as is done by previous works.
'''

# here put the import lib
import networkx as nx

from ai4code.features.preprocessing.android import APKAnalyzer
from ai4code.features.normalization import GraphStatistics
from ai4code.features.resources import get_resource

PACKAGES = get_resource("package_abs")

class MaMaDroidAnalyzer(APKAnalyzer):
    def __init__(self, apkpath, ana_obj=None):
        super(MaMaDroidAnalyzer, self).__init__(apkpath, ana_obj=ana_obj)
        self.cg = self.get_call_graph()
        self.features = self._get_features()

    def get_features(self):
        return self.features

    def _get_features(self):
        """ 
        node:
            <analysis.MethodAnalysis Landroid/support/annotation/CheckResult;->suggest()Ljava/lang/String; [access_flags=public abstract] @ 0x0>
            class_name: Landroid/support/annotation/CheckResult; 
            full_name: Landroid/support/annotation/CheckResult; suggest ()Ljava/lang/String;
        edge:
            (<analysis.MethodAnalysis Landroid/support/annotation/RestrictTo$Scope;-><clinit>()V [access_flags=static constructor] @ 0xcace0>, <analysis.MethodAnalysis Landroid/support/annotation/RestrictTo$Scope;-><init>(Ljava/lang/String; I)V [access_flags=private constructor] @ 0xcad88>, 54)
        """

        mappings = dict()
        for node in self.cg.nodes: 
            abstracted_name = abstract_package(node)
            mappings[node] = abstracted_name
                
        abs_cg = nx.relabel_nodes(self.cg, mappings)

        graph_analysis = GraphStatistics(abs_cg)
        transition_matrix = graph_analysis.get_trans_matrix(align_names=PACKAGES)

        # adjacency_matrix = nx.to_numpy_array(abs_cg) 
        # node_list = list(abs_cg.nodes())
        # transition_matrix = np.nan_to_num(adjacency_matrix / adjacency_matrix.sum(axis=0))
        # transition_matrix = pd.DataFrame(transition_matrix, columns=node_list)
        # transition_matrix.index = node_list
        
        # init_features = pd.DataFrame(np.zeros([len(packages), len(packages)]), columns=packages)
        # init_features.index = packages
        # _, transition_matrix = init_features.align(transition_matrix, fill_value=0)

        return transition_matrix


def abstract_package(call, packages=PACKAGES, sep=".", classL=False):
    call = unify_pkg_name(call.class_name, sep=sep, classL=classL) # keep (sep, classL) with the packages 
    candidates = dict()

    for p in packages:
        if call.startswith(p):
            depth = len(call.split("/"))
            candidates[depth] = p
    
    if candidates:
        canKeys = list(candidates.keys())
        canKeys.sort()
        package = candidates[canKeys[-1]]
    else:
        package = 'self-defined'

    # print(call, ' -> ', package)
    return package


def unify_pkg_name(name, sep=".", classL=False):
    name = str(name)
    if not classL:
        name = name.strip('L')
    if sep == '.' and '/' in name:
        return name.replace('/', '.')
    elif sep == '/' and '.' in name:
        return name.replace('.', '/')
    else:
        return name
