#!/usr/bin/env python
# -*- encoding: utf-8 -*-
'''
@File    :   GraphDroid.py
@Time    :   2021/10/04 21:11:44
@Author  :   Yiling He
@Version :   1.0
@Contact :   heyilinge0@gmail.com
@License :   (C)Copyright 2021
@Desc    :   None
'''

# here put the import lib
import os.path as osp
from ai4code.features.preprocessing.android import APKAnalyzer
from ai4code.features.resources import get_resource, INSTRUCTION_CLASSES, INSTRUCTION_SET_COLOR
from ai4code.features.normalization import get_existence_vector, get_frequency_vector, concatenate_numpy_array, \
    get_k_hop_subgraph, convert_graph_data
from examples.android_malware_detection.mamadroid import abstract_package


PERMISSIONS = get_resource('android_permissions')
opcode_specified = False
OPCODES = get_resource('samli_opcodes') if opcode_specified else INSTRUCTION_CLASSES
PACKAGES = get_resource('package_abs')

class GraphDroidAnalyzer(APKAnalyzer):
    def __init__(self, apkpath, ana_obj=None): # , apk_label
        super(GraphDroidAnalyzer, self).__init__(apkpath, ana_obj=ana_obj)
        # self.label = apk_label
        self.features = self.get_snippet_subgraphs()

    def get_snippet_subgraphs(self, hop=2):
        call_graph = self.get_call_graph()
        snippet_subgraphs = []
        sensitive_apis = {mx: per_list for mx, per_list in self.get_used_permissions()}
        tpl_pkgs = self.get_tpl_pkgs()
        
        if hop is None:
            attributed_graph = self.get_subgraph_attributes(call_graph, None, tpl_pkgs, sensitive_apis)
            snippet_subgraphs.append(attributed_graph)
        else:
            for mx, _ in sensitive_apis.items():
                # API -> Context
                # malicious code is implemented in several snippets around sensitive APIs
                mx_subgraph = get_k_hop_subgraph(call_graph, mx, hop)
                mx_attributed_subgraph = self.get_subgraph_attributes(mx_subgraph, str(mx.full_name), tpl_pkgs, sensitive_apis)
                snippet_subgraphs.append(mx_attributed_subgraph)
        
        return snippet_subgraphs

    def get_subgraph_attributes(self, mx_subgraph, sensitive_api, tpl_pkgs, sensitive_apis, dim=None):
        node_attributes = []
        node_api = []
        node_types = [] # internal(TPL, SELF), external(SENSITIVE, INSEN)
        if dim is None:
            dim = len(PERMISSIONS) + len(OPCODES) + len(PACKAGES) + 1

        for node in mx_subgraph.nodes:
            node_per_attr = get_existence_vector([], PERMISSIONS) # requested permissions
            node_opc_attr = get_existence_vector([], OPCODES) # internal opcodes of the method
            node_pkg_attr = self.get_pkg_vector(abstract_package(node)) # abstracted package name
            
            pkg = abstract_package(node, packages=list(tpl_pkgs.keys()), sep="/", classL=True)
            tpl_flag = pkg != 'self-defined'
            if tpl_flag:
                # Understanding Third-Party Libraries in Mobile App Analysis: Recent studies showed that third-party libraries account for more than 60% of the code in Android apps on average.          
                node_types.append(0)
                node_per_attr = self.get_permission_vector(per_list=tpl_pkgs[pkg], mode='tpl')
                # print(tpl_pkgs[pkg], node_per_attr)
            
            if node in sensitive_apis.keys(): # sensitive API
                node_types.append(1)
                node_per_attr = self.get_permission_vector(per_list=sensitive_apis[node], mode='api')
            elif not node.is_external(): # tpl /self-defined method
                if not tpl_flag: node_types.append(2)
                node_opc_attr = self.get_opcode_vector(opc_list=self.get_method_tokens(node))
            else: # insensitive API
                node_types.append(3)
                
            # print(node.full_name, len(node_per_attr), len(node_opc_attr), len(node_pkg_attr))
            node_attr = concatenate_numpy_array([node_per_attr, node_opc_attr, node_pkg_attr]) # 231 + 15(224) + 445 =691(900)
            assert len(node_attr) == dim, f"Expected {dim} but got {len(node_attr)}"
            node_attributes.append(node_attr)

            node_api.append(str(node.full_name))

        # reset node index in the edge list
        edge_list = []
        for src, dst, _ in list(mx_subgraph.edges):
            edge_list.append([node_api.index(str(api.full_name)) for api in [src, dst]])

        subgraph_dict = {"node_attributes": node_attributes, "edge_list": edge_list, \
            "mapping": node_api, "app": osp.splitext(self.filepath)[0], "center": sensitive_api, "types": node_types} # , "label": self.label

        return convert_graph_data(subgraph_dict)

    def get_permission_vector(self, per_list, mode):
        if mode == 'api':
            permission_vector = get_existence_vector(per_list, PERMISSIONS)
        elif mode == 'tpl':
            permission_vector = get_existence_vector([], PERMISSIONS)
            if len(per_list):
                for api_permissions in per_list:
                    permission_vector += get_existence_vector(api_permissions, PERMISSIONS)
                permission_vector = permission_vector / len(per_list)
        return permission_vector

    def get_opcode_vector(self, opc_list, specific=False):
        if specific:
            return self.get_opcode_vector_specific(opc_list)
        
        opc_class_list = []
        for opc in opc_list:
            opc_class_list.append(OPCODES[INSTRUCTION_SET_COLOR[opc]])
        return get_frequency_vector(opc_class_list, OPCODES, divide=True)
    
    def get_opcode_vector_specific(self, opc_list):
        return get_frequency_vector(opc_list, OPCODES)

    def get_pkg_vector(self, pkg_name):
        return get_existence_vector([pkg_name], PACKAGES, handle_undefined=True)